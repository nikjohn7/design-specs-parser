"""Synthetic tests for generated schedules with ground truth (Phase 5.5).

These tests validate the parser against synthetic workbooks generated by
`tools/generate_programa_test_schedules.py` where each `.xlsx` has a matching
`.truth.json` containing the expected schedule name and product fields.
"""

from __future__ import annotations

import json
import math
import re
from pathlib import Path
from typing import Any

import pytest
from fastapi.testclient import TestClient

from app.parser.workbook import load_workbook_safe
from tests.synthetic_helpers import post_parse, validate_schema

pytestmark = [pytest.mark.synthetic, pytest.mark.synthetic_generated]


def _norm_text(value: str | None) -> str | None:
    if value is None:
        return None
    s = re.sub(r"\s+", " ", value).strip()
    if not s:
        return ""
    return s.casefold()


def _index_by_doc_code(products: list[dict[str, Any]]) -> dict[str, dict[str, Any]]:
    indexed: dict[str, dict[str, Any]] = {}
    for product in products:
        doc_code = (product.get("doc_code") or "").strip()
        if not doc_code:
            continue
        indexed[doc_code] = product
    return indexed


def _load_truth(truth_path: Path) -> dict[str, Any]:
    truth = json.loads(truth_path.read_text(encoding="utf-8"))
    assert isinstance(truth, dict), f"{truth_path.name}: truth must be a JSON object"
    assert isinstance(truth.get("schedule_name"), str), f"{truth_path.name}: missing schedule_name"
    assert isinstance(truth.get("products"), list), f"{truth_path.name}: missing products list"
    return truth


def _workbook_contains_text(xlsx_bytes: bytes, needle: str) -> bool:
    needle_norm = needle.strip().casefold()
    if not needle_norm:
        return False
    wb = load_workbook_safe(xlsx_bytes)
    for ws in wb.worksheets:
        for row in ws.iter_rows(min_row=1, max_row=20, min_col=1, max_col=10, values_only=True):
            for value in row:
                if not isinstance(value, str):
                    continue
                if needle_norm in value.casefold():
                    return True
    return False


def _require_rate(
    *,
    actual: int,
    total: int,
    min_rate: float,
    message: str,
) -> None:
    if total <= 0:
        return
    rate = actual / total
    assert rate >= min_rate, f"{message} ({actual}/{total} = {rate:.1%}, expected >= {min_rate:.1%})"


def test_generated_files_schema_valid(client: TestClient, generated_files: list[tuple[Path, Path]]) -> None:
    for xlsx_path, truth_path in generated_files:
        data = post_parse(client, xlsx_path)
        validate_schema(data)


def test_generated_files_schedule_name_matches_truth(
    client: TestClient, generated_files: list[tuple[Path, Path]]
) -> None:
    for xlsx_path, truth_path in generated_files:
        truth = _load_truth(truth_path)
        xlsx_bytes = xlsx_path.read_bytes()
        if not _workbook_contains_text(xlsx_bytes, truth["schedule_name"]):
            pytest.skip(f"{xlsx_path.name}: workbook does not contain truth schedule_name")
        response = client.post(
            "/parse",
            files={
                "file": (
                    xlsx_path.name,
                    xlsx_bytes,
                    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                )
            },
        )
        assert response.status_code == 200, f"{xlsx_path.name}: {response.text[:400]}"
        data = response.json()
        assert (data.get("schedule_name") or "").strip() == truth["schedule_name"].strip(), xlsx_path.name


def test_generated_files_doc_code_overlap(
    client: TestClient, generated_files: list[tuple[Path, Path]]
) -> None:
    for xlsx_path, truth_path in generated_files:
        truth = _load_truth(truth_path)
        if not truth.get("notes", {}).get("include_code_col", True):
            continue

        truth_codes = {(p.get("doc_code") or "").strip() for p in truth["products"]}
        truth_codes.discard("")
        if not truth_codes:
            continue

        data = post_parse(client, xlsx_path)
        parsed_codes = {(p.get("doc_code") or "").strip() for p in (data.get("products") or [])}
        parsed_codes.discard("")

        overlap = len(truth_codes & parsed_codes) / len(truth_codes)
        assert overlap >= 0.70, f"{xlsx_path.name}: doc_code overlap {overlap:.1%} < 70%"


def test_generated_files_quality_against_truth(
    client: TestClient, generated_files: list[tuple[Path, Path]]
) -> None:
    for xlsx_path, truth_path in generated_files:
        truth = _load_truth(truth_path)
        if not truth.get("notes", {}).get("include_code_col", True):
            continue

        expected_products = truth["products"]
        if not expected_products:
            continue

        data = post_parse(client, xlsx_path)
        parsed_products = data.get("products") or []

        expected_count = len(expected_products)
        actual_count = len(parsed_products)
        lower = math.floor(expected_count * 0.80)
        upper = math.ceil(expected_count * 1.20)
        assert lower <= actual_count <= upper, (
            f"{xlsx_path.name}: product count {actual_count} not within ±20% of {expected_count} "
            f"(expected {lower}..{upper})"
        )

        truth_by_code = {p["doc_code"].strip(): p for p in expected_products if (p.get("doc_code") or "").strip()}
        parsed_by_code = _index_by_doc_code(parsed_products)
        overlapping_codes = sorted(set(truth_by_code) & set(parsed_by_code))

        if not overlapping_codes:
            pytest.skip(f"{xlsx_path.name}: no overlapping doc_codes to compare")

        # Text fields: evaluate equality on normalized text, requiring a reasonable match rate.
        name_total = 0
        name_matches = 0
        brand_total = 0
        brand_matches = 0
        for doc_code in overlapping_codes:
            truth_product = truth_by_code[doc_code]
            parsed_product = parsed_by_code[doc_code]

            truth_name = _norm_text(truth_product.get("product_name"))
            if truth_name is not None:
                name_total += 1
                if _norm_text(parsed_product.get("product_name")) == truth_name:
                    name_matches += 1

            truth_brand = _norm_text(truth_product.get("brand"))
            if truth_brand is not None:
                brand_total += 1
                if _norm_text(parsed_product.get("brand")) == truth_brand:
                    brand_matches += 1

        _require_rate(
            actual=name_matches,
            total=name_total,
            min_rate=0.70,
            message=f"{xlsx_path.name}: low product_name match rate",
        )
        _require_rate(
            actual=brand_matches,
            total=brand_total,
            min_rate=0.70,
            message=f"{xlsx_path.name}: low brand match rate",
        )

        # Numeric fields: when extracted, must be within tolerance; also require reasonable fill-rate.
        def compare_int_field(field: str, *, abs_tol: int = 1) -> None:
            for doc_code in overlapping_codes:
                truth_value = truth_by_code[doc_code].get(field)
                if truth_value is None:
                    continue
                parsed_value = parsed_by_code[doc_code].get(field)
                if parsed_value is None:
                    continue
                assert abs(int(parsed_value) - int(truth_value)) <= abs_tol, (
                    f"{xlsx_path.name}: {field} mismatch for {doc_code}: "
                    f"got {parsed_value!r}, expected {truth_value!r} ±{abs_tol}"
                )

        def compare_rrp_field(*, abs_tol: float = 0.05) -> None:
            for doc_code in overlapping_codes:
                truth_value = truth_by_code[doc_code].get("rrp")
                if truth_value is None:
                    continue
                parsed_value = parsed_by_code[doc_code].get("rrp")
                if parsed_value is None:
                    continue
                truth_num = float(truth_value)
                parsed_num = float(parsed_value)
                allowed = max(abs_tol, truth_num * 0.20)
                assert abs(parsed_num - truth_num) <= allowed, (
                    f"{xlsx_path.name}: rrp mismatch for {doc_code}: got {parsed_value!r}, expected {truth_value!r} "
                    f"(±{allowed:.2f})"
                )

        compare_int_field("qty", abs_tol=0)
        compare_int_field("width", abs_tol=2)
        compare_int_field("length", abs_tol=2)
        compare_int_field("height", abs_tol=2)
        compare_rrp_field(abs_tol=0.50)
